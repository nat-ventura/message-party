// Code generated by protoc-gen-gopherjs. DO NOT EDIT.
// source: chat_service.proto

/*
	Package proto is a generated protocol buffer package.

	It is generated from these files:
		chat_service.proto

	It has these top-level messages:
		WebMessage
		WebResponse
*/
package proto

import jspb "github.com/johanbrandhorst/protobuf/jspb"

// This is a compile-time assertion to ensure that this generated file
// is compatible with the jspb package it is being compiled against.
const _ = jspb.JspbPackageIsVersion2

type WebMessage struct {
	// Types that are valid to be assigned to Content:
	//	*WebMessage_Name
	//	*WebMessage_Message
	Content isWebMessage_Content
}

// isWebMessage_Content is used to distinguish types assignable to Content
type isWebMessage_Content interface{ isWebMessage_Content() }

// WebMessage_Name is assignable to Content
type WebMessage_Name struct {
	Name string
}

// WebMessage_Message is assignable to Content
type WebMessage_Message struct {
	Message string
}

func (*WebMessage_Name) isWebMessage_Content()    {}
func (*WebMessage_Message) isWebMessage_Content() {}

// GetContent gets the Content of the WebMessage.
func (m *WebMessage) GetContent() (x isWebMessage_Content) {
	if m == nil {
		return x
	}
	return m.Content
}

// GetName gets the Name of the WebMessage.
func (m *WebMessage) GetName() (x string) {
	if v, ok := m.GetContent().(*WebMessage_Name); ok {
		return v.Name
	}
	return x
}

// GetMessage gets the Message of the WebMessage.
func (m *WebMessage) GetMessage() (x string) {
	if v, ok := m.GetContent().(*WebMessage_Message); ok {
		return v.Message
	}
	return x
}

// MarshalToWriter marshals WebMessage to the provided writer.
func (m *WebMessage) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	switch t := m.Content.(type) {
	case *WebMessage_Name:
		if len(t.Name) > 0 {
			writer.WriteString(1, t.Name)
		}
	case *WebMessage_Message:
		if len(t.Message) > 0 {
			writer.WriteString(2, t.Message)
		}
	}

	return
}

// Marshal marshals WebMessage to a slice of bytes.
func (m *WebMessage) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a WebMessage from the provided reader.
func (m *WebMessage) UnmarshalFromReader(reader jspb.Reader) *WebMessage {
	for reader.Next() {
		if m == nil {
			m = &WebMessage{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Content = &WebMessage_Name{
				Name: reader.ReadString(),
			}
		case 2:
			m.Content = &WebMessage_Message{
				Message: reader.ReadString(),
			}
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a WebMessage from a slice of bytes.
func (m *WebMessage) Unmarshal(rawBytes []byte) (*WebMessage, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type WebResponse struct {
	Message string
}

// GetMessage gets the Message of the WebResponse.
func (m *WebResponse) GetMessage() (x string) {
	if m == nil {
		return x
	}
	return m.Message
}

// MarshalToWriter marshals WebResponse to the provided writer.
func (m *WebResponse) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Message) > 0 {
		writer.WriteString(2, m.Message)
	}

	return
}

// Marshal marshals WebResponse to a slice of bytes.
func (m *WebResponse) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a WebResponse from the provided reader.
func (m *WebResponse) UnmarshalFromReader(reader jspb.Reader) *WebResponse {
	for reader.Next() {
		if m == nil {
			m = &WebResponse{}
		}

		switch reader.GetFieldNumber() {
		case 2:
			m.Message = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a WebResponse from a slice of bytes.
func (m *WebResponse) Unmarshal(rawBytes []byte) (*WebResponse, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}
