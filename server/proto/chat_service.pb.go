// Code generated by protoc-gen-go. DO NOT EDIT.
// source: proto/chat_service.proto

package proto

import proto1 "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type WebMessage struct {
	// Types that are valid to be assigned to Content:
	//	*WebMessage_Name
	//	*WebMessage_Message
	Content isWebMessage_Content `protobuf_oneof:"content"`
}

func (m *WebMessage) Reset()                    { *m = WebMessage{} }
func (m *WebMessage) String() string            { return proto1.CompactTextString(m) }
func (*WebMessage) ProtoMessage()               {}
func (*WebMessage) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

type isWebMessage_Content interface{ isWebMessage_Content() }

type WebMessage_Name struct {
	Name string `protobuf:"bytes,1,opt,name=name,oneof"`
}
type WebMessage_Message struct {
	Message string `protobuf:"bytes,2,opt,name=message,oneof"`
}

func (*WebMessage_Name) isWebMessage_Content()    {}
func (*WebMessage_Message) isWebMessage_Content() {}

func (m *WebMessage) GetContent() isWebMessage_Content {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *WebMessage) GetName() string {
	if x, ok := m.GetContent().(*WebMessage_Name); ok {
		return x.Name
	}
	return ""
}

func (m *WebMessage) GetMessage() string {
	if x, ok := m.GetContent().(*WebMessage_Message); ok {
		return x.Message
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*WebMessage) XXX_OneofFuncs() (func(msg proto1.Message, b *proto1.Buffer) error, func(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error), func(msg proto1.Message) (n int), []interface{}) {
	return _WebMessage_OneofMarshaler, _WebMessage_OneofUnmarshaler, _WebMessage_OneofSizer, []interface{}{
		(*WebMessage_Name)(nil),
		(*WebMessage_Message)(nil),
	}
}

func _WebMessage_OneofMarshaler(msg proto1.Message, b *proto1.Buffer) error {
	m := msg.(*WebMessage)
	// content
	switch x := m.Content.(type) {
	case *WebMessage_Name:
		b.EncodeVarint(1<<3 | proto1.WireBytes)
		b.EncodeStringBytes(x.Name)
	case *WebMessage_Message:
		b.EncodeVarint(2<<3 | proto1.WireBytes)
		b.EncodeStringBytes(x.Message)
	case nil:
	default:
		return fmt.Errorf("WebMessage.Content has unexpected type %T", x)
	}
	return nil
}

func _WebMessage_OneofUnmarshaler(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error) {
	m := msg.(*WebMessage)
	switch tag {
	case 1: // content.name
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Content = &WebMessage_Name{x}
		return true, err
	case 2: // content.message
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Content = &WebMessage_Message{x}
		return true, err
	default:
		return false, nil
	}
}

func _WebMessage_OneofSizer(msg proto1.Message) (n int) {
	m := msg.(*WebMessage)
	// content
	switch x := m.Content.(type) {
	case *WebMessage_Name:
		n += proto1.SizeVarint(1<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(len(x.Name)))
		n += len(x.Name)
	case *WebMessage_Message:
		n += proto1.SizeVarint(2<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(len(x.Message)))
		n += len(x.Message)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type WebResponse struct {
	Message string `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
}

func (m *WebResponse) Reset()                    { *m = WebResponse{} }
func (m *WebResponse) String() string            { return proto1.CompactTextString(m) }
func (*WebResponse) ProtoMessage()               {}
func (*WebResponse) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

func (m *WebResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func init() {
	proto1.RegisterType((*WebMessage)(nil), "proto.WebMessage")
	proto1.RegisterType((*WebResponse)(nil), "proto.WebResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ChatService service

type ChatServiceClient interface {
	WebChat(ctx context.Context, opts ...grpc.CallOption) (ChatService_WebChatClient, error)
}

type chatServiceClient struct {
	cc *grpc.ClientConn
}

func NewChatServiceClient(cc *grpc.ClientConn) ChatServiceClient {
	return &chatServiceClient{cc}
}

func (c *chatServiceClient) WebChat(ctx context.Context, opts ...grpc.CallOption) (ChatService_WebChatClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ChatService_serviceDesc.Streams[0], c.cc, "/proto.ChatService/WebChat", opts...)
	if err != nil {
		return nil, err
	}
	x := &chatServiceWebChatClient{stream}
	return x, nil
}

type ChatService_WebChatClient interface {
	Send(*WebMessage) error
	Recv() (*WebResponse, error)
	grpc.ClientStream
}

type chatServiceWebChatClient struct {
	grpc.ClientStream
}

func (x *chatServiceWebChatClient) Send(m *WebMessage) error {
	return x.ClientStream.SendMsg(m)
}

func (x *chatServiceWebChatClient) Recv() (*WebResponse, error) {
	m := new(WebResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for ChatService service

type ChatServiceServer interface {
	WebChat(ChatService_WebChatServer) error
}

func RegisterChatServiceServer(s *grpc.Server, srv ChatServiceServer) {
	s.RegisterService(&_ChatService_serviceDesc, srv)
}

func _ChatService_WebChat_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ChatServiceServer).WebChat(&chatServiceWebChatServer{stream})
}

type ChatService_WebChatServer interface {
	Send(*WebResponse) error
	Recv() (*WebMessage, error)
	grpc.ServerStream
}

type chatServiceWebChatServer struct {
	grpc.ServerStream
}

func (x *chatServiceWebChatServer) Send(m *WebResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *chatServiceWebChatServer) Recv() (*WebMessage, error) {
	m := new(WebMessage)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _ChatService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.ChatService",
	HandlerType: (*ChatServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WebChat",
			Handler:       _ChatService_WebChat_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "proto/chat_service.proto",
}

func init() { proto1.RegisterFile("proto/chat_service.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 173 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x92, 0x28, 0x28, 0xca, 0x2f,
	0xc9, 0xd7, 0x4f, 0xce, 0x48, 0x2c, 0x89, 0x2f, 0x4e, 0x2d, 0x2a, 0xcb, 0x4c, 0x4e, 0xd5, 0x03,
	0x0b, 0x09, 0xb1, 0x82, 0x29, 0x25, 0x4f, 0x2e, 0xae, 0xf0, 0xd4, 0x24, 0xdf, 0xd4, 0xe2, 0xe2,
	0xc4, 0xf4, 0x54, 0x21, 0x11, 0x2e, 0x96, 0xbc, 0xc4, 0xdc, 0x54, 0x09, 0x46, 0x05, 0x46, 0x0d,
	0x4e, 0x0f, 0x86, 0x20, 0x30, 0x4f, 0x48, 0x8a, 0x8b, 0x3d, 0x17, 0xa2, 0x40, 0x82, 0x09, 0x2a,
	0x01, 0x13, 0x70, 0xe2, 0xe4, 0x62, 0x4f, 0xce, 0xcf, 0x2b, 0x49, 0xcd, 0x2b, 0x51, 0x52, 0xe7,
	0xe2, 0x0e, 0x4f, 0x4d, 0x0a, 0x4a, 0x2d, 0x2e, 0xc8, 0xcf, 0x2b, 0x4e, 0x15, 0x92, 0x40, 0xd3,
	0x05, 0xd7, 0x63, 0xe4, 0xca, 0xc5, 0xed, 0x9c, 0x91, 0x58, 0x12, 0x0c, 0x71, 0x8f, 0x90, 0x19,
	0x17, 0x7b, 0x78, 0x6a, 0x12, 0x48, 0x44, 0x48, 0x10, 0xe2, 0x38, 0x3d, 0x84, 0x93, 0xa4, 0x84,
	0x10, 0x42, 0x30, 0xa3, 0x95, 0x18, 0x34, 0x18, 0x0d, 0x18, 0x93, 0xd8, 0xc0, 0x12, 0xc6, 0x80,
	0x00, 0x00, 0x00, 0xff, 0xff, 0x5c, 0x09, 0x78, 0xc4, 0xe4, 0x00, 0x00, 0x00,
}
